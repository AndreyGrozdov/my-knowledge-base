# Проблема обновления приложений
Предположим, у нас есть приложение версии 1.0. Разработчики выпускают новую версию 2.0, которую мы собираем в Docker-образ и загружаем в registry. Теперь необходимо обновить все Pod'ы в кластере Kubernetes, чтобы они использовали новый образ 2.0.
Основная сложность: мы не можем заменить образ уже запущенного Pod'а. После создания Pod остаётся неизменным до своего удаления.

## Три базовых подхода к обновлению
   1. Удалить все существующие Pod'ы, затем запустить новые
       ◦ Простой подход, но приводит к downtime приложения
       ◦ Между удалением старых и запуском новых Pod'ов приложение недоступно
   2. Запустить новые Pod'ы, затем удалить старые
       ◦ Избегаем downtime, но временно работают две версии приложения
       ◦ Проблема: версия 2.0 может накатывать миграции базы данных, несовместимые с версией 1.0
   3. Поэтапное обновление
       ◦ Добавляем по одному новому Pod'у, удаляем по одному старому
       ◦ Минимизирует риски, но требует ручного управления процессом
## Решение: Deployment
### Deployment - это объект Kubernetes, предназначенный для декларативного управления развертыванием и обновлением приложений. Он автоматически координирует создание и изменение ReplicaSet'ов во время обновления

Как работает Deployment:
Deployment создает и управляет двумя ReplicaSet'ами:
Во время обновления Deployment:
- Автоматически откатывает изменения при возникновении проблем
- Обеспечивает, что в любой момент времени работает нужное количество Pod'ов
- Соответственно уменьшает количество реплик в старом ReplicaSet
- Постепенно увеличивает количество реплик в новом ReplicaSet
- Новый ReplicaSet - управляет Pod'ами новой версии
- Старый ReplicaSet - управляет Pod'ами предыдущей версии
### Преимущества Deployment
- Декларативный подход - описываем желаемое состояние, Kubernetes сам достигает его
- Health checks - проверяет готовность новых Pod'ов перед удалением старых
- Автоматический rollback - при неудачном обновлении автоматически возвращается к предыдущей версии
- Zero-downtime deployments - приложение доступно throughout всего процесса обновления

```yaml
apiVersion: apps/v1          # Версия API для работы с Deployment
kind: Deployment              # Тип ресурса - Deployment (управляет Pod'ами)
metadata:                     # Метаданные ресурса
  name: qa-deployment         # Имя Deployment (должно быть уникальным)
spec:                         # Спецификация (желаемое состояние)
  replicas: 3                 # Количество копий Pod'ов (реплик)
  selector:                   # Селектор для поиска управляемых Pod'ов
    matchLabels:              # Условия поиска по меткам
      app: app                # Ищем Pod'ы с меткой app=app
  template:                   # Шаблон для создания Pod'ов
    metadata:                 # Метаданные Pod'ов
      labels:                 # Метки для Pod'ов
        app: app              # Метка app=app (должна совпадать с selector)
    spec:                     # Спецификация Pod'ов
      containers:             # Список контейнеров в Pod'е
      - name: app             # Имя контейнера (нужно для обновлений)
        image: app:v1.0       # Docker образ и его версия
```

# Команды:

```bash
kubectl create -f deployment.yaml                #создание деплоя из ямл файла   можно подставить --record для записи измкенений
kubectl get deployment                           #Посмотреть созданный деплой
kubectl rollout status deployment qa-deployment  #Посмотреть статус деплоя  (вместо qa-deployment подставить своё имя деплоя)
kubectl get replicaset                           #Посмотреть replicaset которую создал наш деплой
kubectl delete deployment qa-deployment          #Удалить деплоймент (вместо qa-deployment подставить своё имя деплоя)
kubectl apply -f вeployment.yaml                 #создание деплоя из ямл файла

```
***

# Стратегия обновления подов
- RollingUpdate -стратегия по умолчанию, удаляет старые поды и одновременно добавляет новые.
- Recreate - удаляет все старые поды перед созданием новых

## RollingUpdate Strategy
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  strategy:
    type: RollingUpdate              # Стратегия "Постепенное обновление"
    rollingUpdate:
      maxSurge: 25%                  # Максимум на 25% больше Pod'ов во время обновления (можно указать абсолютное значение)
      maxUnavailable: 25%            # Максимум 25% недоступных Pod'ов во время обновления (можно указать абсолютное значение)
  selector:
    matchLabels:
      app: nginx                     # Ищем Pod'ы с меткой app=nginx
  template:
    # ... шаблон Pod'а
```
Характеристики RollingUpdate:
- ✅ Без даунтайма - приложение доступно во время обновления
- ✅ Постепенная замена - старые и новые версии работают одновременно
- ✅ Контроль нагрузки - можно регулировать скорость обновления
- ⚠️ Временная несовместимость - две версии работают одновременно

## Recreate Strategy
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  strategy:
    type: Recreate                   # Стратегия "Пересоздание"
  selector:
    matchLabels:
      app: nginx                     # Ищем Pod'ы с меткой app=nginx
  template:
    # ... шаблон Pod'а
```
Характеристики Recreate:
- ✅ Простая логика - сначала удалить все старые, потом создать новые
- ✅ Нет несовместимости - только одна версия работает в каждый момент
- ❌ Даунтайм - приложение недоступно во время обновления
- ⚠️ Потеря сессий - все подключения разрываются
